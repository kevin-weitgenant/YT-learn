/**
 * âš ï¸ DEPRECATED: YouTube Chapter Extraction via ytInitialData
 *
 * @deprecated This file is DEPRECATED as of 2025-11-27.
 *
 * NEW METHOD: Chapter extraction now uses InnerTube API description parsing.
 * See: youtubeTranscriptFast.ts -> extractChaptersFromInnerTubeDescription()
 *
 * REASON FOR DEPRECATION:
 * - ytInitialData doesn't refresh when users change videos in the same tab (YouTube SPA navigation)
 * - This caused chapters to display stale data from the previous video
 * - The new method calls InnerTube API which provides fresh data on every extraction
 *
 * SOLUTION:
 * - Extract chapters from playerData.videoDetails.shortDescription via InnerTube /player API
 * - Parse timestamp-based chapters from description text (e.g., "0:00 Introduction")
 * - Works perfectly with SPA navigation since we call the API fresh each time
 *
 * This file is kept for historical reference only.
 * Do NOT use these functions in new code.
 *
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *
 * OLD DOCUMENTATION (for reference):
 *
 * Extracts video chapters/timestamps from YouTube's ytInitialData object.
 * As a Chrome extension content script, we have direct access to the page's
 * JavaScript context, so we can read ytInitialData without any HTTP requests.
 *
 * Supports both:
 * - DESCRIPTION_CHAPTERS: Manually added by creator
 * - AUTO_CHAPTERS: Automatically generated by YouTube
 *
 * Performance: ~5-10ms (instant JavaScript object navigation)
 */

import type { Chapter } from '~types/transcript';

/**
 * Internal: Raw chapter data structure from ytInitialData
 */
interface RawChapterRenderer {
  chapterRenderer: {
    title: {
      simpleText: string;
    };
    timeRangeStartMillis: number;
    thumbnail?: {
      thumbnails: Array<{
        url: string;
        width: number;
        height: number;
      }>;
    };
  };
}

/**
 * Internal: Marker structure in ytInitialData.markersMap
 */
interface ChapterMarker {
  key: string;  // "DESCRIPTION_CHAPTERS" or "AUTO_CHAPTERS"
  value: {
    chapters: RawChapterRenderer[];
  };
}

/**
 * Access ytInitialData from page context with retry logic
 *
 * ytInitialData is a global object embedded in YouTube's watch page.
 * As a content script, we can access it directly via window object.
 *
 * Since YouTube is an SPA, ytInitialData may not be immediately available
 * when the page loads or navigates. This function implements retry logic
 * to wait for ytInitialData to become available.
 *
 * @param maxRetries - Maximum number of retry attempts (default: 10)
 * @param delayMs - Delay between retries in milliseconds (default: 200ms)
 * @returns ytInitialData object or null if not found after all retries
 */
async function getYtInitialData(maxRetries: number = 10, delayMs: number = 200): Promise<any> {
  console.log('[Chapters] ğŸ” Attempting to get ytInitialData with retry logic...');

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      // Try accessing directly from window
      if (typeof window !== 'undefined' && (window as any).ytInitialData) {
        console.log(`[Chapters] âœ… Found ytInitialData on window object (attempt ${attempt}/${maxRetries})`);
        console.log('[Chapters] Debug: ytInitialData keys:', Object.keys((window as any).ytInitialData));
        return (window as any).ytInitialData;
      }

      // Fallback: Parse from script tags in the page
      const scripts = document.querySelectorAll('script');

      for (const script of Array.from(scripts)) {
        const content = script.textContent || '';

        // Look for: var ytInitialData = {...};
        const match = content.match(/var ytInitialData = ({.+?});/);
        if (match && match[1]) {
          try {
            const data = JSON.parse(match[1]);
            console.log(`[Chapters] âœ… Successfully parsed ytInitialData from script tag (attempt ${attempt}/${maxRetries})`);
            return data;
          } catch (e) {
            // Continue to next script tag
            continue;
          }
        }
      }

      // Not found on this attempt
      if (attempt < maxRetries) {
        console.log(`[Chapters] â³ ytInitialData not ready yet, waiting ${delayMs}ms before retry ${attempt + 1}/${maxRetries}...`);
        await new Promise(resolve => setTimeout(resolve, delayMs));
      }
    } catch (error) {
      console.error(`[Chapters] âŒ Error on attempt ${attempt}/${maxRetries}:`, error);
      if (attempt < maxRetries) {
        await new Promise(resolve => setTimeout(resolve, delayMs));
      }
    }
  }

  console.warn(`[Chapters] âŒ ytInitialData not found after ${maxRetries} attempts`);
  return null;
}

/**
 * Navigate JSON path to find chapter markers
 *
 * Path: ytInitialData
 *   â†’ playerOverlays
 *     â†’ playerOverlayRenderer
 *       â†’ decoratedPlayerBarRenderer
 *         â†’ decoratedPlayerBarRenderer
 *           â†’ playerBar
 *             â†’ multiMarkersPlayerBarRenderer
 *               â†’ markersMap[]
 *
 * @param ytInitialData - The ytInitialData object
 * @returns Array of chapter markers or empty array
 */
function findChapterMarkers(ytInitialData: any): ChapterMarker[] {
  try {
    console.log('[Chapters] ğŸ” Navigating to markersMap...');
    console.log('[Chapters] Debug: playerOverlays exists:', !!ytInitialData?.playerOverlays);

    const playerOverlayRenderer = ytInitialData?.playerOverlays?.playerOverlayRenderer;
    console.log('[Chapters] Debug: playerOverlayRenderer exists:', !!playerOverlayRenderer);

    const decoratedPlayerBarRenderer = playerOverlayRenderer?.decoratedPlayerBarRenderer?.decoratedPlayerBarRenderer;
    console.log('[Chapters] Debug: decoratedPlayerBarRenderer exists:', !!decoratedPlayerBarRenderer);

    const multiMarkersPlayerBarRenderer = decoratedPlayerBarRenderer?.playerBar?.multiMarkersPlayerBarRenderer;
    console.log('[Chapters] Debug: multiMarkersPlayerBarRenderer exists:', !!multiMarkersPlayerBarRenderer);

    const markersMap = multiMarkersPlayerBarRenderer?.markersMap;

    if (!markersMap || !Array.isArray(markersMap)) {
      console.log('[Chapters] âŒ markersMap not found or not an array');
      console.log('[Chapters] Debug: markersMap value:', markersMap);
      return [];
    }

    console.log(`[Chapters] âœ… Found markersMap with ${markersMap.length} marker(s)`);
    console.log('[Chapters] Debug: marker keys:', markersMap.map((m: any) => m.key));
    return markersMap;
  } catch (error) {
    console.error('[Chapters] âŒ Error navigating to markersMap:', error);
    return [];
  }
}

/**
 * Extract chapters from markers
 *
 * Prefers DESCRIPTION_CHAPTERS (manual) over AUTO_CHAPTERS (auto-generated)
 *
 * @param markers - Array of chapter markers from ytInitialData
 * @returns Array of chapters with title and timestamp
 */
function extractChaptersFromMarkers(markers: ChapterMarker[]): Chapter[] {
  try {
    console.log('[Chapters] ğŸ” Extracting chapters from markers...');
    console.log(`[Chapters] Debug: Processing ${markers.length} marker(s)`);

    // Look for DESCRIPTION_CHAPTERS first (manual), then AUTO_CHAPTERS (auto)
    let chaptersData: RawChapterRenderer[] | null = null;
    let chapterType = '';

    for (const marker of markers) {
      const key = marker.key?.toUpperCase();
      console.log(`[Chapters] Debug: Checking marker with key: "${key}"`);

      if (key === 'DESCRIPTION_CHAPTERS') {
        chaptersData = marker.value?.chapters;
        chapterType = 'DESCRIPTION_CHAPTERS';
        console.log('[Chapters] âœ… Found DESCRIPTION_CHAPTERS (manual)');
        console.log(`[Chapters] Debug: DESCRIPTION_CHAPTERS count: ${chaptersData?.length ?? 0}`);
        break; // Prefer manual chapters
      } else if (key === 'AUTO_CHAPTERS' && !chaptersData) {
        chaptersData = marker.value?.chapters;
        chapterType = 'AUTO_CHAPTERS';
        console.log('[Chapters] âœ… Found AUTO_CHAPTERS (auto-generated)');
        console.log(`[Chapters] Debug: AUTO_CHAPTERS count: ${chaptersData?.length ?? 0}`);
      }
    }

    if (!chaptersData || !Array.isArray(chaptersData) || chaptersData.length === 0) {
      console.log('[Chapters] âŒ No chapters found in markers');
      console.log('[Chapters] Debug: chaptersData:', chaptersData);
      return [];
    }

    console.log(`[Chapters] âœ… Extracting ${chaptersData.length} chapters from ${chapterType}`);

    // Parse chapters
    const chapters: Chapter[] = chaptersData
      .map((item: RawChapterRenderer, index: number) => {
        try {
          const renderer = item.chapterRenderer;
          if (!renderer) {
            console.warn(`[Chapters] Chapter ${index} missing chapterRenderer`);
            return null;
          }

          const title = renderer.title?.simpleText;
          const timeMs = renderer.timeRangeStartMillis;

          if (!title || typeof timeMs !== 'number') {
            console.warn(`[Chapters] Chapter ${index} missing title or timestamp`);
            return null;
          }

          // Convert milliseconds to seconds
          const startSeconds = Math.floor(timeMs / 1000);

          return {
            title,
            startSeconds
          };
        } catch (error) {
          console.warn(`[Chapters] Error parsing chapter ${index}:`, error);
          return null;
        }
      })
      .filter((chapter): chapter is Chapter => chapter !== null);

    return chapters;
  } catch (error) {
    console.error('[Chapters] Error extracting chapters from markers:', error);
    return [];
  }
}

/**
 * Extract video chapters from YouTube page
 *
 * @deprecated DO NOT USE - This function is deprecated!
 * Use extractChaptersFromInnerTubeDescription() from youtubeTranscriptFast.ts instead.
 *
 * Main public function - call this to get chapters.
 * Accesses ytInitialData from page context with retry logic to handle timing issues.
 * Returns empty array if no chapters found or on error.
 *
 * @param videoId - YouTube video ID (used for logging only)
 * @returns Promise resolving to array of chapters with title and startSeconds, or empty array
 *
 * @example
 * const chapters = await extractChapters('dQw4w9WgXcQ');
 * // [
 * //   { title: "Introduction", startSeconds: 0 },
 * //   { title: "Main Content", startSeconds: 83 },
 * //   { title: "Conclusion", startSeconds: 245 }
 * // ]
 */
export async function extractChapters(videoId: string): Promise<Chapter[]> {
  const startTime = Date.now();

  try {
    console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    console.log(`[Chapters] ğŸ¬ Starting chapter extraction for video: ${videoId}`);
    console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');

    // Step 1: Get ytInitialData from page (with retry logic)
    console.log('[Chapters] STEP 1: Getting ytInitialData from page (with retry logic)...');
    const ytInitialData = await getYtInitialData();
    if (!ytInitialData) {
      console.log('[Chapters] âŒ FAILED at STEP 1: ytInitialData not available after retries');
      console.log('[Chapters] Result: Returning empty array');
      return [];
    }
    console.log('[Chapters] âœ… STEP 1 COMPLETE: ytInitialData retrieved');

    // Step 2: Navigate to markersMap
    console.log('[Chapters] STEP 2: Navigating to markersMap...');
    const markers = findChapterMarkers(ytInitialData);
    if (markers.length === 0) {
      console.log('[Chapters] âŒ FAILED at STEP 2: No markers found');
      console.log('[Chapters] Result: Video likely has no chapters');
      return [];
    }
    console.log(`[Chapters] âœ… STEP 2 COMPLETE: Found ${markers.length} marker(s)`);

    // Step 3: Extract chapters from markers
    console.log('[Chapters] STEP 3: Extracting chapters from markers...');
    const chapters = extractChaptersFromMarkers(markers);

    const duration = Date.now() - startTime;

    if (chapters.length > 0) {
      console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
      console.log(`[Chapters] âœ…âœ…âœ… SUCCESS: Extracted ${chapters.length} chapter(s) in ${duration}ms`);
      console.log('[Chapters] Chapters data:', chapters);
      console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    } else {
      console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
      console.log(`[Chapters] âš ï¸ STEP 3 COMPLETE but no chapters extracted (${duration}ms)`);
      console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    }

    return chapters;
  } catch (error) {
    const duration = Date.now() - startTime;
    console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    console.error(`[Chapters] âŒâŒâŒ ERROR: Exception during extraction (${duration}ms):`, error);
    console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    return []; // Return empty array on error (graceful failure)
  }
}

/**
 * Format seconds to human-readable timestamp
 *
 * Utility function for displaying chapters in UI
 *
 * @param seconds - Time in seconds
 * @returns Formatted string like "1:23" or "1:23:45"
 *
 * @example
 * formatTimestamp(0) // "0:00"
 * formatTimestamp(83) // "1:23"
 * formatTimestamp(3661) // "1:01:01"
 */
export function formatTimestamp(seconds: number): string {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = seconds % 60;

  if (hours > 0) {
    return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  } else {
    return `${minutes}:${secs.toString().padStart(2, '0')}`;
  }
}

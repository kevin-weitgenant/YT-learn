/**
 * YouTube Chapter Extraction Utility
 *
 * Extracts video chapters/timestamps from YouTube's ytInitialData object.
 * As a Chrome extension content script, we have direct access to the page's
 * JavaScript context, so we can read ytInitialData without any HTTP requests.
 *
 * Supports both:
 * - DESCRIPTION_CHAPTERS: Manually added by creator
 * - AUTO_CHAPTERS: Automatically generated by YouTube
 *
 * Performance: ~5-10ms (instant JavaScript object navigation)
 */

import type { Chapter } from '~types/transcript';

/**
 * Internal: Raw chapter data structure from ytInitialData
 */
interface RawChapterRenderer {
  chapterRenderer: {
    title: {
      simpleText: string;
    };
    timeRangeStartMillis: number;
    thumbnail?: {
      thumbnails: Array<{
        url: string;
        width: number;
        height: number;
      }>;
    };
  };
}

/**
 * Internal: Marker structure in ytInitialData.markersMap
 */
interface ChapterMarker {
  key: string;  // "DESCRIPTION_CHAPTERS" or "AUTO_CHAPTERS"
  value: {
    chapters: RawChapterRenderer[];
  };
}

/**
 * Access ytInitialData from page context
 *
 * ytInitialData is a global object embedded in YouTube's watch page.
 * As a content script, we can access it directly via window object.
 *
 * @returns ytInitialData object or null if not found
 */
function getYtInitialData(): any {
  try {
    // Try accessing directly from window
    if (typeof window !== 'undefined' && (window as any).ytInitialData) {
      console.log('[Chapters] Found ytInitialData on window object');
      return (window as any).ytInitialData;
    }

    // Fallback: Parse from script tags in the page
    console.log('[Chapters] Attempting to parse ytInitialData from script tags');
    const scripts = document.querySelectorAll('script');
    for (const script of Array.from(scripts)) {
      const content = script.textContent || '';

      // Look for: var ytInitialData = {...};
      const match = content.match(/var ytInitialData = ({.+?});/);
      if (match && match[1]) {
        try {
          return JSON.parse(match[1]);
        } catch (e) {
          console.warn('[Chapters] Failed to parse ytInitialData from script tag:', e);
          continue;
        }
      }
    }

    console.warn('[Chapters] ytInitialData not found');
    return null;
  } catch (error) {
    console.error('[Chapters] Error accessing ytInitialData:', error);
    return null;
  }
}

/**
 * Navigate JSON path to find chapter markers
 *
 * Path: ytInitialData
 *   → playerOverlays
 *     → playerOverlayRenderer
 *       → decoratedPlayerBarRenderer
 *         → decoratedPlayerBarRenderer
 *           → playerBar
 *             → multiMarkersPlayerBarRenderer
 *               → markersMap[]
 *
 * @param ytInitialData - The ytInitialData object
 * @returns Array of chapter markers or empty array
 */
function findChapterMarkers(ytInitialData: any): ChapterMarker[] {
  try {
    const markersMap = ytInitialData
      ?.playerOverlays
      ?.playerOverlayRenderer
      ?.decoratedPlayerBarRenderer
      ?.decoratedPlayerBarRenderer
      ?.playerBar
      ?.multiMarkersPlayerBarRenderer
      ?.markersMap;

    if (!markersMap || !Array.isArray(markersMap)) {
      console.log('[Chapters] markersMap not found or not an array');
      return [];
    }

    console.log(`[Chapters] Found markersMap with ${markersMap.length} marker(s)`);
    return markersMap;
  } catch (error) {
    console.error('[Chapters] Error navigating to markersMap:', error);
    return [];
  }
}

/**
 * Extract chapters from markers
 *
 * Prefers DESCRIPTION_CHAPTERS (manual) over AUTO_CHAPTERS (auto-generated)
 *
 * @param markers - Array of chapter markers from ytInitialData
 * @returns Array of chapters with title and timestamp
 */
function extractChaptersFromMarkers(markers: ChapterMarker[]): Chapter[] {
  try {
    // Look for DESCRIPTION_CHAPTERS first (manual), then AUTO_CHAPTERS (auto)
    let chaptersData: RawChapterRenderer[] | null = null;
    let chapterType = '';

    for (const marker of markers) {
      const key = marker.key?.toUpperCase();

      if (key === 'DESCRIPTION_CHAPTERS') {
        chaptersData = marker.value?.chapters;
        chapterType = 'DESCRIPTION_CHAPTERS';
        console.log('[Chapters] Found DESCRIPTION_CHAPTERS (manual)');
        break; // Prefer manual chapters
      } else if (key === 'AUTO_CHAPTERS' && !chaptersData) {
        chaptersData = marker.value?.chapters;
        chapterType = 'AUTO_CHAPTERS';
        console.log('[Chapters] Found AUTO_CHAPTERS (auto-generated)');
      }
    }

    if (!chaptersData || !Array.isArray(chaptersData) || chaptersData.length === 0) {
      console.log('[Chapters] No chapters found in markers');
      return [];
    }

    console.log(`[Chapters] Extracting ${chaptersData.length} chapters from ${chapterType}`);

    // Parse chapters
    const chapters: Chapter[] = chaptersData
      .map((item: RawChapterRenderer, index: number) => {
        try {
          const renderer = item.chapterRenderer;
          if (!renderer) {
            console.warn(`[Chapters] Chapter ${index} missing chapterRenderer`);
            return null;
          }

          const title = renderer.title?.simpleText;
          const timeMs = renderer.timeRangeStartMillis;

          if (!title || typeof timeMs !== 'number') {
            console.warn(`[Chapters] Chapter ${index} missing title or timestamp`);
            return null;
          }

          // Convert milliseconds to seconds
          const startSeconds = Math.floor(timeMs / 1000);

          return {
            title,
            startSeconds
          };
        } catch (error) {
          console.warn(`[Chapters] Error parsing chapter ${index}:`, error);
          return null;
        }
      })
      .filter((chapter): chapter is Chapter => chapter !== null);

    return chapters;
  } catch (error) {
    console.error('[Chapters] Error extracting chapters from markers:', error);
    return [];
  }
}

/**
 * Extract video chapters from YouTube page
 *
 * Main public function - call this to get chapters.
 * Accesses ytInitialData from page context (instant - no HTTP requests).
 * Returns empty array if no chapters found or on error.
 *
 * @param videoId - YouTube video ID (used for logging only)
 * @returns Array of chapters with title and startSeconds, or empty array
 *
 * @example
 * const chapters = extractChapters('dQw4w9WgXcQ');
 * // [
 * //   { title: "Introduction", startSeconds: 0 },
 * //   { title: "Main Content", startSeconds: 83 },
 * //   { title: "Conclusion", startSeconds: 245 }
 * // ]
 */
export function extractChapters(videoId: string): Chapter[] {
  const startTime = Date.now();

  try {
    console.log(`[Chapters] Extracting chapters for video: ${videoId}`);

    // Step 1: Get ytInitialData from page
    const ytInitialData = getYtInitialData();
    if (!ytInitialData) {
      console.log('[Chapters] ytInitialData not available - returning empty array');
      return [];
    }

    // Step 2: Navigate to markersMap
    const markers = findChapterMarkers(ytInitialData);
    if (markers.length === 0) {
      console.log('[Chapters] No markers found - video likely has no chapters');
      return [];
    }

    // Step 3: Extract chapters from markers
    const chapters = extractChaptersFromMarkers(markers);

    const duration = Date.now() - startTime;

    if (chapters.length > 0) {
      console.log(`[Chapters] ✅ Extracted ${chapters.length} chapter(s) in ${duration}ms`);
      console.log('[Chapters] Chapters:', chapters);
    } else {
      console.log(`[Chapters] ℹ️ No chapters found for this video (${duration}ms)`);
    }

    return chapters;
  } catch (error) {
    const duration = Date.now() - startTime;
    console.error(`[Chapters] ❌ Error extracting chapters (${duration}ms):`, error);
    return []; // Return empty array on error (graceful failure)
  }
}

/**
 * Format seconds to human-readable timestamp
 *
 * Utility function for displaying chapters in UI
 *
 * @param seconds - Time in seconds
 * @returns Formatted string like "1:23" or "1:23:45"
 *
 * @example
 * formatTimestamp(0) // "0:00"
 * formatTimestamp(83) // "1:23"
 * formatTimestamp(3661) // "1:01:01"
 */
export function formatTimestamp(seconds: number): string {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = seconds % 60;

  if (hours > 0) {
    return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  } else {
    return `${minutes}:${secs.toString().padStart(2, '0')}`;
  }
}

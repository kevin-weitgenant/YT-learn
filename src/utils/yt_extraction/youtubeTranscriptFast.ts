/**
 * Fast YouTube Transcript Extraction via InnerTube API
 *
 * This module provides direct access to YouTube's internal InnerTube API
 * for fast transcript extraction (~100-300ms vs ~5-10s DOM scraping).
 *
 * The InnerTube API is YouTube's internal API used by all YouTube clients
 * (web, mobile, TV apps). We access it directly to get caption track URLs.
 *
 * Key advantages:
 * - 20-50x faster than DOM scraping
 * - Works from Chrome extension (same-origin, real browser)
 * - No authentication needed (uses browser's cookies)
 * - Returns structured data with all available subtitle tracks
 */

import { extractVideoId } from './youtubeTranscript';
import type { Chapter, TranscriptSegment } from '~types/transcript';

/**
 * Public interface for subtitle track metadata
 */
export interface SubtitleTrack {
  /** ISO language code (e.g., "en", "es", "pt") */
  languageCode: string;

  /** Human-readable language name (e.g., "English", "Spanish") */
  languageName: string;

  /** true if auto-generated (ASR), false if manually created */
  isAutoGenerated: boolean;

  /** YouTube's internal identifier (e.g., ".en" or "a.en") */
  vssId: string;

  /** Internal: Direct URL to fetch transcript (for internal use) */
  baseUrl: string;
}

/**
 * Internal: InnerTube API request context
 */
interface InnerTubeContext {
  context: {
    client: {
      clientName: string;
      clientVersion: string;
    };
  };
  videoId: string;
}

/**
 * Internal: Raw caption track from InnerTube API response
 */
interface RawCaptionTrack {
  baseUrl: string;
  name: {
    simpleText?: string;
    runs?: Array<{ text: string }>;
  };
  vssId: string;
  languageCode: string;
  kind?: string;
  isTranslatable: boolean;
}

/**
 * Internal: InnerTube player API response structure (partial)
 */
interface InnerTubePlayerResponse {
  captions?: {
    playerCaptionsTracklistRenderer?: {
      captionTracks?: RawCaptionTrack[];
    };
  };
  videoDetails?: {
    videoId?: string;
    title?: string;
    shortDescription?: string;
    lengthSeconds?: string;
    author?: string;
    channelId?: string;
    viewCount?: string;
  };
  streamingData?: any;
}

/**
 * Call YouTube InnerTube Player API
 *
 * Makes POST request to /youtubei/v1/player endpoint
 * Uses WEB client context (we are the real browser!)
 * Browser automatically includes cookies (user auth)
 *
 * @param videoId - YouTube video ID (11 characters)
 * @returns Raw InnerTube API response
 * @throws Error if API call fails
 */
async function callInnerTubePlayerAPI(videoId: string): Promise<InnerTubePlayerResponse> {
  console.log('[InnerTube] Calling player API for video:', videoId);

  const response = await fetch('https://www.youtube.com/youtubei/v1/player', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      // Browser automatically adds:
      // - User-Agent (real Chrome)
      // - Cookie (user's session)
      // - Referer (current page)
    },
    body: JSON.stringify({
      context: {
        client: {
          clientName: 'WEB',
          clientVersion: '2.20240101.00.00'
        }
      },
      videoId: videoId
    })
  });

  if (!response.ok) {
    throw new Error(
      `InnerTube API returned ${response.status}: ${response.statusText}`
    );
  }

  const data = await response.json();
  console.log('[InnerTube] API call successful');

  return data;
}

/**
 * List all available subtitles for a video
 *
 * NO automatic selection - returns ALL available tracks
 * Caller decides which one to use
 *
 * @param videoId - YouTube video ID
 * @returns Array of subtitle tracks with metadata
 * @throws Error if API call fails or no subtitles exist
 *
 * @example
 * const tracks = await listAvailableSubtitles('dQw4w9WgXcQ');
 * console.log(tracks);
 * // [
 * //   { languageCode: 'en', languageName: 'English', isAutoGenerated: true, ... },
 * //   { languageCode: 'es', languageName: 'Spanish', isAutoGenerated: false, ... }
 * // ]
 */
export async function listAvailableSubtitles(videoId: string): Promise<SubtitleTrack[]> {
  const playerData = await callInnerTubePlayerAPI(videoId);

  // Navigate to caption tracks in response
  const rawTracks = playerData?.captions
    ?.playerCaptionsTracklistRenderer
    ?.captionTracks;

  if (!rawTracks || rawTracks.length === 0) {
    throw new Error('No subtitles available for this video');
  }

  console.log(`[InnerTube] Found ${rawTracks.length} subtitle track(s)`);

  // Transform to clean public interface
  return rawTracks.map((track: RawCaptionTrack) => {
    // Handle different name formats
    const languageName = track.name?.simpleText
      || track.name?.runs?.[0]?.text
      || 'Unknown';

    return {
      languageCode: track.languageCode,
      languageName: languageName,
      isAutoGenerated: track.kind === 'asr',
      vssId: track.vssId,
      baseUrl: track.baseUrl
    };
  });
}

/**
 * Fetch transcript XML from YouTube's timedtext API
 *
 * @param baseUrl - Direct URL from caption track
 * @returns Raw XML string
 * @throws Error if fetch fails or response is empty
 */
async function fetchTranscriptXML(baseUrl: string): Promise<string> {
  console.log('[InnerTube] Fetching transcript XML...');

  const response = await fetch(baseUrl);

  if (!response.ok) {
    throw new Error(
      `Failed to fetch transcript: ${response.status} ${response.statusText}`
    );
  }

  const xmlText = await response.text();

  if (xmlText.length === 0) {
    throw new Error('Transcript response is empty');
  }

  console.log(`[InnerTube] Fetched ${xmlText.length} bytes of XML`);

  return xmlText;
}

/**
 * Parse XML transcript to plain text
 *
 * Uses regex instead of DOMParser to avoid Trusted Types security issues
 * Extracts text content from <text> tags
 *
 * @param xmlText - Raw XML from timedtext API
 * @returns Object containing plain text transcript and segments
 * @throws Error if no text segments found
 *
 * @example
 * const xml = '<?xml...><text start="0">Hello</text><text start="2">World</text></transcript>';
 * const { text, segments } = parseXMLTranscript(xml);
 * // text: "Hello World"
 * // segments: [{text: "Hello", start: 0, duration: ...}, ...]
 */
function parseXMLTranscript(xmlText: string): { text: string; segments: TranscriptSegment[] } {
  // Regex: Match <text ...>CONTENT</text>
  // Capture group 1 = attributes, group 2 = CONTENT
  const textMatches = xmlText.matchAll(/<text([^>]*)>([^<]*)<\/text>/g);

  const segments: TranscriptSegment[] = [];
  const textParts: string[] = [];

  for (const match of textMatches) {
    const attributes = match[1];
    const content = match[2];
    
    // Extract start and dur from attributes
    const startMatch = attributes.match(/start="([\d.]+)"/);
    const durMatch = attributes.match(/dur="([\d.]+)"/);

    if (startMatch && content) {
      const start = parseFloat(startMatch[1]);
      const duration = durMatch ? parseFloat(durMatch[1]) : 0;
      // Decode HTML entities in content if needed (basic ones)
      const text = content.replace(/&amp;/g, '&')
                          .replace(/&lt;/g, '<')
                          .replace(/&gt;/g, '>')
                          .replace(/&quot;/g, '"')
                          .replace(/&#39;/g, "'");

      segments.push({
        text,
        start,
        duration
      });
      textParts.push(text);
    }
  }

  if (segments.length === 0) {
    throw new Error('No text segments found in transcript XML');
  }

  console.log(`[InnerTube] Parsed ${segments.length} text segments`);

  // Join with spaces
  return {
    text: textParts.join(' ').trim(),
    segments
  };
}

/**
 * Fetch transcript for a SPECIFIC language
 *
 * Caller specifies which language - we don't impose preferences
 *
 * @param videoId - YouTube video ID
 * @param languageCode - ISO language code (e.g., "en", "es", "pt")
 * @param preferManual - If true and both manual+auto exist, prefer manual
 * @returns Transcript text
 * @throws Error if language not available
 *
 * @example
 * // Get English transcript (prefer manual over auto)
 * const transcript = await fetchTranscriptByLanguage('dQw4w9WgXcQ', 'en', true);
 */
export async function fetchTranscriptByLanguage(
  videoId: string,
  languageCode: string,
  preferManual: boolean = false
): Promise<{ transcriptSegments: TranscriptSegment[] }> {
  const startTime = Date.now();

  // Get all available tracks
  const tracks = await listAvailableSubtitles(videoId);

  // Filter by language
  const matchingTracks = tracks.filter(t => t.languageCode === languageCode);

  if (matchingTracks.length === 0) {
    const available = tracks.map(t => t.languageCode).join(', ');
    throw new Error(
      `No subtitles available for language "${languageCode}". ` +
      `Available languages: ${available}`
    );
  }

  // Select track based on preference
  let selectedTrack = matchingTracks[0];

  if (preferManual && matchingTracks.length > 1) {
    const manualTrack = matchingTracks.find(t => !t.isAutoGenerated);
    if (manualTrack) {
      selectedTrack = manualTrack;
      console.log('[InnerTube] Using manual captions (preferred)');
    }
  }

  console.log(
    `[InnerTube] Selected: ${selectedTrack.languageName} ` +
    `(${selectedTrack.isAutoGenerated ? 'auto' : 'manual'})`
  );

  // Fetch and parse
  const xmlText = await fetchTranscriptXML(selectedTrack.baseUrl);
  const { text, segments } = parseXMLTranscript(xmlText);

  const duration = Date.now() - startTime;
  console.log(`[InnerTube] Transcript fetched in ${duration}ms (${text.length} chars)`);

  return { transcriptSegments: segments };
}

/**
 * Fetch first available transcript (no preferences)
 *
 * Simple convenience function for "just give me something" use case
 * Takes whatever YouTube lists first
 *
 * @param videoId - YouTube video ID
 * @returns Object with transcript + metadata about which track was used
 *
 * @example
 * const result = await fetchFirstAvailableTranscript('dQw4w9WgXcQ');
 * console.log(result.transcript);
 * console.log(`Language: ${result.languageName} (${result.isAutoGenerated ? 'auto' : 'manual'})`);
 */
export async function fetchFirstAvailableTranscript(videoId: string): Promise<{
  transcriptSegments: TranscriptSegment[];
  languageCode: string;
  languageName: string;
  isAutoGenerated: boolean;
}> {
  const tracks = await listAvailableSubtitles(videoId);
  const firstTrack = tracks[0];

  console.log(`[InnerTube] Using first available: ${firstTrack.languageName}`);

  const { transcriptSegments } = await fetchTranscriptByLanguage(videoId, firstTrack.languageCode);

  return {
    transcriptSegments,
    languageCode: firstTrack.languageCode,
    languageName: firstTrack.languageName,
    isAutoGenerated: firstTrack.isAutoGenerated
  };
}

/**
 * Parse timestamp string to seconds
 *
 * Supports multiple formats:
 * - "0:00" -> 0
 * - "1:23" -> 83
 * - "1:23:45" -> 5025
 *
 * @param timestamp - Timestamp string
 * @returns Seconds or null if invalid
 *
 * @example
 * parseTimestamp("1:23") // 83
 * parseTimestamp("1:23:45") // 5025
 */
function parseTimestamp(timestamp: string): number | null {
  const parts = timestamp.split(':').map(part => parseInt(part.trim(), 10));

  if (parts.some(isNaN)) {
    return null;
  }

  if (parts.length === 2) {
    // MM:SS format
    const [minutes, seconds] = parts;
    return minutes * 60 + seconds;
  } else if (parts.length === 3) {
    // HH:MM:SS format
    const [hours, minutes, seconds] = parts;
    return hours * 3600 + minutes * 60 + seconds;
  }

  return null;
}

/**
 * Parse chapters from video description text
 *
 * Extracts timestamp-based chapters from YouTube video descriptions.
 * Supports various common formats:
 * - "0:00 Introduction"
 * - "1:23 - Main Topic"
 * - "[0:00] Intro"
 * - "0:00:00 Long Format"
 *
 * @param description - Video description text
 * @returns Array of chapters or empty array if none found
 *
 * @example
 * const desc = "0:00 Intro\n1:23 Main Content\n5:45 Outro";
 * const chapters = parseChaptersFromDescription(desc);
 * // [
 * //   { title: "Intro", startSeconds: 0 },
 * //   { title: "Main Content", startSeconds: 83 },
 * //   { title: "Outro", startSeconds: 345 }
 * // ]
 */
export function parseChaptersFromDescription(description: string): Chapter[] {
  if (!description || typeof description !== 'string') {
    console.log('[Chapters] No description provided');
    return [];
  }

  console.log(`[Chapters] üìù Parsing chapters from description (${description.length} chars)...`);

  // Split into lines
  const lines = description.split('\n');

  // Regex patterns for timestamp formats
  // Matches: [0:00], (0:00), 0:00, with optional dash/colon/hyphen separators
  const timestampPattern = /^[\[\(]?(\d{1,2}:\d{2}(?::\d{2})?)[\]\)]?\s*[-:]?\s*(.+)$/;

  const chapters: Chapter[] = [];

  for (const line of lines) {
    const trimmedLine = line.trim();

    if (!trimmedLine) {
      continue;
    }

    const match = trimmedLine.match(timestampPattern);

    if (match) {
      const [, timestampStr, titleStr] = match;
      const startSeconds = parseTimestamp(timestampStr);
      const title = titleStr.trim();

      if (startSeconds !== null && title.length > 0) {
        chapters.push({
          title,
          startSeconds
        });
      }
    }
  }

  if (chapters.length > 0) {
    // Sort by timestamp (should already be sorted, but ensure it)
    chapters.sort((a, b) => a.startSeconds - b.startSeconds);

    console.log(`[Chapters] ‚úÖ Parsed ${chapters.length} chapter(s) from description`);
    console.log('[Chapters] Chapter titles:', chapters.map(c => c.title));
  } else {
    console.log('[Chapters] ‚ÑπÔ∏è No chapters found in description');
  }

  return chapters;
}

/**
 * Extract chapters from InnerTube API video description
 *
 * Calls InnerTube Player API and extracts chapters from video description.
 * This method provides fresh data on every call, solving the SPA navigation
 * issue where ytInitialData doesn't refresh on video changes.
 *
 * @param videoId - YouTube video ID
 * @returns Array of chapters or empty array if none found
 *
 * @example
 * const chapters = await extractChaptersFromInnerTubeDescription('dQw4w9WgXcQ');
 * // [
 * //   { title: "Introduction", startSeconds: 0 },
 * //   { title: "Main Content", startSeconds: 83 }
 * // ]
 */
export async function extractChaptersFromInnerTubeDescription(videoId: string): Promise<Chapter[]> {
  console.log('[Chapters] üé¨ Extracting chapters from InnerTube API description...');
  console.log(`[Chapters] Video ID: ${videoId}`);

  try {
    // Call InnerTube API
    const playerData = await callInnerTubePlayerAPI(videoId);

    // Get description
    const description = playerData?.videoDetails?.shortDescription;

    if (!description) {
      console.log('[Chapters] ‚ÑπÔ∏è No description found in InnerTube response');
      return [];
    }

    console.log(`[Chapters] üìÑ Description length: ${description.length} characters`);

    // Parse chapters from description
    const chapters = parseChaptersFromDescription(description);

    return chapters;

  } catch (error) {
    console.error('[Chapters] ‚ùå Error extracting chapters from InnerTube:', error);
    return []; // Graceful failure
  }
}

/**
 * Fast YouTube Transcript Extraction via InnerTube API
 *
 * This module provides direct access to YouTube's internal InnerTube API
 * for fast transcript extraction (~100-300ms vs ~5-10s DOM scraping).
 *
 * The InnerTube API is YouTube's internal API used by all YouTube clients
 * (web, mobile, TV apps). We access it directly to get caption track URLs.
 *
 * Key advantages:
 * - 20-50x faster than DOM scraping
 * - Works from Chrome extension (same-origin, real browser)
 * - No authentication needed (uses browser's cookies)
 * - Returns structured data with all available subtitle tracks
 */

import { extractVideoId } from './youtubeTranscript';

/**
 * Public interface for subtitle track metadata
 */
export interface SubtitleTrack {
  /** ISO language code (e.g., "en", "es", "pt") */
  languageCode: string;

  /** Human-readable language name (e.g., "English", "Spanish") */
  languageName: string;

  /** true if auto-generated (ASR), false if manually created */
  isAutoGenerated: boolean;

  /** YouTube's internal identifier (e.g., ".en" or "a.en") */
  vssId: string;

  /** Internal: Direct URL to fetch transcript (for internal use) */
  baseUrl: string;
}

/**
 * Internal: InnerTube API request context
 */
interface InnerTubeContext {
  context: {
    client: {
      clientName: string;
      clientVersion: string;
    };
  };
  videoId: string;
}

/**
 * Internal: Raw caption track from InnerTube API response
 */
interface RawCaptionTrack {
  baseUrl: string;
  name: {
    simpleText?: string;
    runs?: Array<{ text: string }>;
  };
  vssId: string;
  languageCode: string;
  kind?: string;
  isTranslatable: boolean;
}

/**
 * Internal: InnerTube player API response structure (partial)
 */
interface InnerTubePlayerResponse {
  captions?: {
    playerCaptionsTracklistRenderer?: {
      captionTracks?: RawCaptionTrack[];
    };
  };
  videoDetails?: any;
  streamingData?: any;
}

/**
 * Call YouTube InnerTube Player API
 *
 * Makes POST request to /youtubei/v1/player endpoint
 * Uses WEB client context (we are the real browser!)
 * Browser automatically includes cookies (user auth)
 *
 * @param videoId - YouTube video ID (11 characters)
 * @returns Raw InnerTube API response
 * @throws Error if API call fails
 */
async function callInnerTubePlayerAPI(videoId: string): Promise<InnerTubePlayerResponse> {
  console.log('[InnerTube] Calling player API for video:', videoId);

  const response = await fetch('https://www.youtube.com/youtubei/v1/player', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      // Browser automatically adds:
      // - User-Agent (real Chrome)
      // - Cookie (user's session)
      // - Referer (current page)
    },
    body: JSON.stringify({
      context: {
        client: {
          clientName: 'WEB',
          clientVersion: '2.20240101.00.00'
        }
      },
      videoId: videoId
    })
  });

  if (!response.ok) {
    throw new Error(
      `InnerTube API returned ${response.status}: ${response.statusText}`
    );
  }

  const data = await response.json();
  console.log('[InnerTube] API call successful');

  return data;
}

/**
 * List all available subtitles for a video
 *
 * NO automatic selection - returns ALL available tracks
 * Caller decides which one to use
 *
 * @param videoId - YouTube video ID
 * @returns Array of subtitle tracks with metadata
 * @throws Error if API call fails or no subtitles exist
 *
 * @example
 * const tracks = await listAvailableSubtitles('dQw4w9WgXcQ');
 * console.log(tracks);
 * // [
 * //   { languageCode: 'en', languageName: 'English', isAutoGenerated: true, ... },
 * //   { languageCode: 'es', languageName: 'Spanish', isAutoGenerated: false, ... }
 * // ]
 */
export async function listAvailableSubtitles(videoId: string): Promise<SubtitleTrack[]> {
  const playerData = await callInnerTubePlayerAPI(videoId);

  // Navigate to caption tracks in response
  const rawTracks = playerData?.captions
    ?.playerCaptionsTracklistRenderer
    ?.captionTracks;

  if (!rawTracks || rawTracks.length === 0) {
    throw new Error('No subtitles available for this video');
  }

  console.log(`[InnerTube] Found ${rawTracks.length} subtitle track(s)`);

  // Transform to clean public interface
  return rawTracks.map((track: RawCaptionTrack) => {
    // Handle different name formats
    const languageName = track.name?.simpleText
      || track.name?.runs?.[0]?.text
      || 'Unknown';

    return {
      languageCode: track.languageCode,
      languageName: languageName,
      isAutoGenerated: track.kind === 'asr',
      vssId: track.vssId,
      baseUrl: track.baseUrl
    };
  });
}

/**
 * Fetch transcript XML from YouTube's timedtext API
 *
 * @param baseUrl - Direct URL from caption track
 * @returns Raw XML string
 * @throws Error if fetch fails or response is empty
 */
async function fetchTranscriptXML(baseUrl: string): Promise<string> {
  console.log('[InnerTube] Fetching transcript XML...');

  const response = await fetch(baseUrl);

  if (!response.ok) {
    throw new Error(
      `Failed to fetch transcript: ${response.status} ${response.statusText}`
    );
  }

  const xmlText = await response.text();

  if (xmlText.length === 0) {
    throw new Error('Transcript response is empty');
  }

  console.log(`[InnerTube] Fetched ${xmlText.length} bytes of XML`);

  return xmlText;
}

/**
 * Parse XML transcript to plain text
 *
 * Uses regex instead of DOMParser to avoid Trusted Types security issues
 * Extracts text content from <text> tags
 *
 * @param xmlText - Raw XML from timedtext API
 * @returns Plain text transcript (all segments joined)
 * @throws Error if no text segments found
 *
 * @example
 * const xml = '<?xml...><text start="0">Hello</text><text start="2">World</text></transcript>';
 * const text = parseXMLTranscript(xml);
 * // "Hello World"
 */
function parseXMLTranscript(xmlText: string): string {
  // Regex: Match <text ...>CONTENT</text>
  // Capture group 1 = CONTENT
  const textMatches = xmlText.matchAll(/<text[^>]*>([^<]*)<\/text>/g);

  // Extract just the text content (ignore attributes)
  const segments = Array.from(textMatches).map(match => match[1]);

  if (segments.length === 0) {
    throw new Error('No text segments found in transcript XML');
  }

  console.log(`[InnerTube] Parsed ${segments.length} text segments`);

  // Join with spaces
  return segments.join(' ').trim();
}

/**
 * Fetch transcript for a SPECIFIC language
 *
 * Caller specifies which language - we don't impose preferences
 *
 * @param videoId - YouTube video ID
 * @param languageCode - ISO language code (e.g., "en", "es", "pt")
 * @param preferManual - If true and both manual+auto exist, prefer manual
 * @returns Transcript text
 * @throws Error if language not available
 *
 * @example
 * // Get English transcript (prefer manual over auto)
 * const transcript = await fetchTranscriptByLanguage('dQw4w9WgXcQ', 'en', true);
 */
export async function fetchTranscriptByLanguage(
  videoId: string,
  languageCode: string,
  preferManual: boolean = false
): Promise<string> {
  const startTime = Date.now();

  // Get all available tracks
  const tracks = await listAvailableSubtitles(videoId);

  // Filter by language
  const matchingTracks = tracks.filter(t => t.languageCode === languageCode);

  if (matchingTracks.length === 0) {
    const available = tracks.map(t => t.languageCode).join(', ');
    throw new Error(
      `No subtitles available for language "${languageCode}". ` +
      `Available languages: ${available}`
    );
  }

  // Select track based on preference
  let selectedTrack = matchingTracks[0];

  if (preferManual && matchingTracks.length > 1) {
    const manualTrack = matchingTracks.find(t => !t.isAutoGenerated);
    if (manualTrack) {
      selectedTrack = manualTrack;
      console.log('[InnerTube] Using manual captions (preferred)');
    }
  }

  console.log(
    `[InnerTube] Selected: ${selectedTrack.languageName} ` +
    `(${selectedTrack.isAutoGenerated ? 'auto' : 'manual'})`
  );

  // Fetch and parse
  const xmlText = await fetchTranscriptXML(selectedTrack.baseUrl);
  const transcript = parseXMLTranscript(xmlText);

  const duration = Date.now() - startTime;
  console.log(`[InnerTube] Transcript fetched in ${duration}ms (${transcript.length} chars)`);

  return transcript;
}

/**
 * Fetch first available transcript (no preferences)
 *
 * Simple convenience function for "just give me something" use case
 * Takes whatever YouTube lists first
 *
 * @param videoId - YouTube video ID
 * @returns Object with transcript + metadata about which track was used
 *
 * @example
 * const result = await fetchFirstAvailableTranscript('dQw4w9WgXcQ');
 * console.log(result.transcript);
 * console.log(`Language: ${result.languageName} (${result.isAutoGenerated ? 'auto' : 'manual'})`);
 */
export async function fetchFirstAvailableTranscript(videoId: string): Promise<{
  transcript: string;
  languageCode: string;
  languageName: string;
  isAutoGenerated: boolean;
}> {
  const tracks = await listAvailableSubtitles(videoId);
  const firstTrack = tracks[0];

  console.log(`[InnerTube] Using first available: ${firstTrack.languageName}`);

  const transcript = await fetchTranscriptByLanguage(videoId, firstTrack.languageCode);

  return {
    transcript,
    languageCode: firstTrack.languageCode,
    languageName: firstTrack.languageName,
    isAutoGenerated: firstTrack.isAutoGenerated
  };
}
